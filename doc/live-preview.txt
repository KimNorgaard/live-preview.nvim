
==============================================================================
Lua module : require("live-preview")                            *live-preview*

Live preview for markdown, asciidoc, and html files.

To work with API from this plugin, require it in your Lua code: >lua
    local a_name_you_like = require('live-preview')
<

To use any functions provided by this plugin (see below), replace
`live-preview` in that function's tag name with the name you chose above


preview_file({filepath}, {port})                 *live-preview.preview_file()*
    Start live preview

    Parameters: ~
      • {filepath}  (`string`) path to the file
      • {port}      (`number`) port to run the server on

setup({opts})                                           *live-preview.setup()*
    Setup live preview

    Parameters: ~
      • {opts}  (`{commands: {start: string, stop: string}, port: number, browser: string}`, default: {start = "LivePreview", stop = "StopPreview"})
                • commands: {start: string, stop: string} - commands to start
                  and stop live preview
                • port: number - port to run the server on (default: 5500)
                • browser: string - browser to open the preview in (default:
                  "default"). The "default" value will open the preview in
                  system default browser.

stop_preview()                                   *live-preview.stop_preview()*
    Stop live preview


==============================================================================
Live Preview Module : SERVER                             *live-preview.server*

Server class for live-preview.nvim To call this class, do ```lua local Server
= require('live-preview').server.Server >
<


*Server*

    Fields: ~
      • {new}        (`fun(self: Server, webroot: string)`) Constructor
      • {routes}     (`fun(self: Server, path: string): string`) Handle routes
      • {watch_dir}  (`fun(self: Server, func: function)`) Watch a directory
                     for changes and send a message "reload" to a WebSocket
                     client
      • {start}      (`fun(self: Server, ip: string, port: number)`) Start the
                     server
      • {stop}       (`fun(self: Server)`) Stop the server


Server:new({webroot})                       *live-preview.server.Server:new()*
    Constructor

    Parameters: ~
      • {webroot}  (`string`) path to the webroot

Server:routes({path})                    *live-preview.server.Server:routes()*
    Handle routes

    Parameters: ~
      • {path}  (`string`) path from the http request

    Return: ~
        (`string`) path to the file

Server:start({ip}, {port})                *live-preview.server.Server:start()*
    Start the server

    Parameters: ~
      • {ip}    (`string`) IP address to bind to
      • {port}  (`number`) port to bind to

Server:stop()                              *live-preview.server.Server:stop()*
    Stop the server

Server:watch_dir({func})              *live-preview.server.Server:watch_dir()*
    Watch a directory for changes and send a message "reload" to a WebSocket
    client

    Parameters: ~
      • {func}  (`function`) function to call when a change is detected


==============================================================================
Live Preview Module : HANDLER                           *live-preview.handler*

HTTP handler module for server in live-preview.nvim To require this module, do >lua
    local handler = require('live-preview.server.handler')
<


client({client}, {callback})            *live-preview.server.handler.client()*
    Handle a client connection, read the request and send a response

    Parameters: ~
      • {client}    (`uv_tcp_t`) client connection
      • {callback}  (`function`) callback function to handle the result
                    • `err`: Error message, if any (nil if no error)
                    • `data`: Request from the client

    Return: ~
        (`string`) request from the client

request({request})                     *live-preview.server.handler.request()*
    Handle an HTTP request If the request is a websocket upgrade request, it
    will call websocket handshake Otherwise, if it is a GET request, return
    the path from it

    Parameters: ~
      • {request}  (`string`) HTTP request

    Return: ~
        (`{path: string, if_none_match: string}?`) path to the file and
        If-None-Match header

                            *live-preview.server.handler.send_http_response()*
send_http_response({client}, {status}, {content_type}, {body}, {headers})
    Send an HTTP response

    Parameters: ~
      • {client}        (`uv_tcp_t`) client connection
      • {status}        (`string`) for example "200 OK", "404 Not Found", etc.
      • {content_type}  (`string`) MIME type of the response
      • {body}          (`string`) body of the response
      • {headers}       (`table`) (optional) additional headers to include in
                        the response

                                    *live-preview.server.handler.serve_file()*
serve_file({client}, {file_path})
    Serve a file to the client

    Parameters: ~
      • {client}     (`uv_tcp_t`) client connection
      • {file_path}  (`string`) path to the file


==============================================================================
Live Preview Module : WEBSOCKET                       *live-preview.websocket*

WebSocket server implementation To require this module, do >lua
    local websocket = require('live-preview.server.websocket')
<


                                   *live-preview.server.websocket.handshake()*
handshake({client}, {request})
    Handle a WebSocket handshake request

    Parameters: ~
      • {client}   (`uv_tcp_t`) client
      • {request}  (`string`) client request

send({client}, {message})               *live-preview.server.websocket.send()*
    Send a message to a WebSocket client

    Parameters: ~
      • {client}   (`uv_tcp_t`) client
      • {message}  (`string`) message to send


==============================================================================
Live Preview Module : CONTENT_TYPE                 *live-preview.content_type*

Content type module for the server To require this module, do >lua
    local content_type = require('live-preview.server.utils.content_type')
<


get({file_path})                *live-preview.server.utils.content_type.get()*
    Get the content type of a file

    Parameters: ~
      • {file_path}  (`string`) path to the file

    Return: ~
        (`string?`) content type

mime                             *live-preview.server.utils.content_type.mime*
    Table of file extensions and their corresponding MIME types

    Example: >lua
        mime["html"] -- Output : "text/html"
<


==============================================================================
Live Preview Module : ETAG                                 *live-preview.etag*

ETag module To require this module, do >lua
    local etag = require('live-preview.server.utils.etag')
<


generate({file_path})              *live-preview.server.utils.etag.generate()*
    Generate an ETag for a file The Etag is generated based on the
    modification time of the file

    Parameters: ~
      • {file_path}  (`string`) path to the file

    Return: ~
        (`string?`) ETag


==============================================================================
Live Preview Module : UTILS                               *live-preview.utils*

Utility functions for live-preview.nvim


await_term_cmd({cmd})                    *live-preview.utils.await_term_cmd()*
    Execute a shell command and wait for the exit

    Parameters: ~
      • {cmd}  (`string`) terminal command to execute. Term_cmd will use sh or
               pwsh depending on the OS

    Return: ~
        (`table`) a table with fields code, stdout, stderr, signal

get_path_lua_file()                                      *get_path_lua_file()*

get_plugin_path()                       *live-preview.utils.get_plugin_path()*
    Get the path where live-preview is installed

kill_port({port})                             *live-preview.utils.kill_port()*
    Kill a process which is not Neovim running on a port

    Parameters: ~
      • {port}  (`number`)

open_browser({path}, {browser})            *live-preview.utils.open_browser()*
    Open URL in the browser

    Parameters: ~
      • {path}     (`string`)
      • {browser}  (`string`)

sha1({val})                                        *live-preview.utils.sha1()*
    Compute the SHA1 hash of a string. Source :
    https://github.com/glacambre/firenvim/blob/master/lua/firenvim/firenvim-utils.lua

    Parameters: ~
      • {val}  (`string`)

    Return: ~
        (`string`) SHA1 hash

                                     *live-preview.utils.supported_filetype()*
supported_filetype({file_name})
    Check if file name has a supported filetype (html, markdown, asciidoc).
    Warning: this function will call a Vimscript function

    Parameters: ~
      • {file_name}  (`string`)

    Return: ~
        (`filetype`) string | nil

term_cmd({cmd}, {callback})                    *live-preview.utils.term_cmd()*
    Execute a shell commands

    Parameters: ~
      • {cmd}       (`string`) terminal command to execute. Term_cmd will use
                    sh or pwsh depending on the OS
      • {callback}  (`function`) function to call when the command finishes.
                    • code: the exit code of the command
                    • signal: the signal that killed the process
                    • stdout: the standard output of the command
                    • stderr: the standard error of the command

uv_read_file({file_path})                  *live-preview.utils.uv_read_file()*
    Read a file using libuv

    Parameters: ~
      • {file_path}  (`string`)

uv_write_file({file_path})                *live-preview.utils.uv_write_file()*
    Write a file using libuv

    Parameters: ~
      • {file_path}  (`string`)


==============================================================================
Live Preview Module : HEALTH                             *live-preview.health*

To run health check for Live Preview, run >vim
    :checkhealth live-preview
<

This will check if your Neovim version is compatible with Live Preview and if
the commands to open browser are available.


check()                                          *live-preview.health.check()*
    Run health check for Live Preview. This can also be run using
    `:checkhealth live-preview`

    See also: ~
      • https://neovim.io/doc/user/health.html

is_compatible({ver}, {range})            *live-preview.health.is_compatible()*
    Check if the version is compatible with the range

    Parameters: ~
      • {ver}    (`string`) version to check. Example: "0.10.1"
      • {range}  (`string`) range to check against. Example: ">=0.10.0"

    Return: ~
        (`boolean`) true if compatible, false otherwise


 vim:tw=78:ts=8:sw=4:sts=4:et:ft=help:norl:
