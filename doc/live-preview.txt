
==============================================================================
Lua module : require("live-preview")                            *live-preview*

Live preview for markdown, asciidoc, and html files. These are functions for
setting up, starting, and stopping the live preview server.


preview_file({filepath}, {port})            *live-preview.init.preview_file()*
    Start live preview

    Parameters: ~
      • {filepath}  (`string`) path to the file
      • {port}      (`number`) port to run the server on

setup({opts})                                      *live-preview.init.setup()*
    Setup live preview

    Parameters: ~
      • {opts}  (`{commands: {start: string, stop: string}, port: number, browser: string}`)

stop_preview()                              *live-preview.init.stop_preview()*
    Stop live preview


==============================================================================
Lua module: require("live-preview.server")               *live-preview.server*

Server module for live-preview.nvim


*Server*

    Fields: ~
      • {new}                  (`fun(self: Server, webroot: string)`)
                               Constructor
      • {generate_etag}        (`fun(self: Server, file_path: string): string`)
                               Generate an ETag for a file The Etag is
                               generated based on the modification time of the
                               file
      • {get_content_type}     (`fun(self: Server, file_path: string): string`)
                               Get the content type of a file
      • {send_http_response}   (`fun(self: Server, status: string, content_type: string, body: string, headers: table)`)
                               Send an HTTP response to the client
      • {handle_request}       (`fun(self: Server, client: uv.TCP, request: string)`)
                               Handle an HTTP request
      • {handle_client}        (`fun(self: Server)`) Handle a client
                               connection
      • {websocket_handshake}  (`fun(self: Server, request: string)`) Handle a
                               WebSocket handshake request
      • {websocket_send}       (`fun(self: Server, message: string)`) Send a
                               message to a WebSocket client
      • {watch_dir}            (`fun(self: Server, dir: string, client: uv.TCP)`)
                               Watch a directory for changes and send a
                               message "reload" to a WebSocket client
      • {start}                (`fun(self: Server, ip: string, port: number)`)
                               Start the server
      • {stop}                 (`fun(self: Server)`) Stop the server


Server:generate_etag({file_path})                     *Server:generate_etag()*
    Generate an ETag for a file The Etag is generated based on the
    modification time of the file

    Parameters: ~
      • {file_path}  (`string`) path to the file

    Return: ~
        (`string`) ETag

Server:get_content_type({file_path})               *Server:get_content_type()*
    Get the content type of a file

    Parameters: ~
      • {file_path}  (`string`) path to the file

    Return: ~
        (`string`) content type

Server:handle_client()                                *Server:handle_client()*
    Handle a client connection

Server:handle_request({client}, {request})           *Server:handle_request()*
    Handle an HTTP request

    Parameters: ~
      • {client}   (`uv.TCP`) client connection
      • {request}  (`string`) HTTP request

Server:new({webroot})                                           *Server:new()*
    Constructor

    Parameters: ~
      • {webroot}  (`string`) path to the webroot

                                                 *Server:send_http_response()*
Server:send_http_response({status}, {content_type}, {body}, {headers})
    Send an HTTP response to the client

    Parameters: ~
      • {status}        (`string`) HTTP status code
      • {content_type}  (`string`) HTTP content type
      • {body}          (`string`) response body
      • {headers}       (`table`) response headers

Server:start({ip}, {port})                                    *Server:start()*
    Start the server

    Parameters: ~
      • {ip}    (`string`) IP address to bind to
      • {port}  (`number`) port to bind to

Server:stop()                                                  *Server:stop()*
    Stop the server

Server:watch_dir({dir}, {client})                         *Server:watch_dir()*
    Watch a directory for changes and send a message "reload" to a WebSocket
    client

    Parameters: ~
      • {dir}     (`string`) path to the directory
      • {client}  (`uv.TCP`) WebSocket client

Server:websocket_handshake({request})           *Server:websocket_handshake()*
    Handle a WebSocket handshake request

    Parameters: ~
      • {request}  (`string`) client request

Server:websocket_send({message})                     *Server:websocket_send()*
    Send a message to a WebSocket client

    Parameters: ~
      • {message}  (`string`) message to send


==============================================================================
Lua module: require("live-preview.utils")                 *live-preview.utils*

Utility functions for live-preview.nvim


await_term_cmd                             *live-preview.utils.await_term_cmd*
    Execute a shell command and wait for the exit

    Parameters: ~
      • {cmd}  (`string`)

    Return: ~
        (`table`) a table with fields code, stdout, stderr, signal

get_path_lua_file                       *live-preview.utils.get_path_lua_file*
    Get the path of the current lua file

get_plugin_path()                       *live-preview.utils.get_plugin_path()*
    Get the path where live-preview is installed

kill_port                                       *live-preview.utils.kill_port*
    Kill a process which is not Neovim running on a port

    Parameters: ~
      • {port}  (`number`)

open_browser                                 *live-preview.utils.open_browser*
    Open URL in the browser

    Parameters: ~
      • {path}     (`string`)
      • {browser}  (`string`)

sha1({val})                                        *live-preview.utils.sha1()*
    Compute the SHA1 hash of a string. Source :
    https://github.com/glacambre/firenvim/blob/master/lua/firenvim/firenvim-utils.lua

    Parameters: ~
      • {val}  (`string`)

    Return: ~
        (`string`) SHA1 hash

                                     *live-preview.utils.supported_filetype()*
supported_filetype({file_name})
    Check if file name has a supported filetype (html, markdown, asciidoc).
    Warning: this function will call a Vimscript function

    Parameters: ~
      • {file_name}  (`string`)

    Return: ~
        (`filetype`) string | nil

term_cmd                                         *live-preview.utils.term_cmd*
    Execute a shell commands

    Parameters: ~
      • {cmd}  (`string`)

    Return: ~
        (`table`) a table with fields code, stdout, stderr, signal

uv_read_file({file_path})                  *live-preview.utils.uv_read_file()*
    Read a file using libuv

    Parameters: ~
      • {file_path}  (`string`)


==============================================================================
Lua module: require("live-preview.health")               *live-preview.health*

To run health check for Live Preview, run >vim
    :checkhealth live-preview
<

This will check if your Neovim version is compatible with Live Preview and if
the commands to open browser are available.



 vim:tw=78:ts=8:sw=4:sts=4:et:ft=help:norl:
